---
name: dev-design-generator
description: 根据需求文档生成详细的前后端开发设计方案，支持功能点澄清、多方案推荐和技术选型理由说明
---

# 前后端开发设计方案生成器 Skill

## 📋 概述

根据需求文档中的功能点，逐一分析并生成详细的前后端技术设计方案。对于不明确的功能点会主动向用户澄清，对于有多种实现路径的功能会推荐多种方案供用户选择，每种方案都附带技术选型理由和适用场景分析。

## 🎯 使用场景

- 需求文档完成后，进入技术设计阶段
- 需要对某个功能模块做前后端方案评估
- 技术选型时需要多方案对比和建议
- 新项目需要从零设计技术架构

## 🔄 工作流程

### 阶段 1：需求文档解析

**你必须先完成以下分析：**

1. **获取需求文档**：
   - 如果用户提供了路径，读取文档内容
   - 如果当前对话中已使用 `requirement-design-skill` 生成了文档，直接使用
   - 如果用户口述需求，先整理为结构化信息

2. **提取功能模块列表**：
   - 从需求文档中识别所有功能模块
   - 为每个模块标注涉及的前端和后端能力

3. **确认已有技术约束**：
   - 是否已确定技术栈（框架、语言、数据库等）
   - 是否有团队技术能力限制
   - 是否有部署环境约束

4. **展示功能清单并确认**：

   ```
   根据需求文档，我识别了以下功能模块需要设计：

   | 序号 | 功能模块 | 涉及层次 | 复杂度 |
   |------|---------|---------|--------|
   | 1 | 用户认证 | 前端 + 后端 | ⭐⭐⭐ |
   | 2 | 任务管理 | 前端 + 后端 | ⭐⭐⭐⭐ |
   | 3 | 数据统计 | 前端 + 后端 | ⭐⭐ |
   | ... | ... | ... | ... |

   请确认：

   1. 以上模块是否正确？需要增加或删除吗？

   2. 设计范围？
      a. 🖥️ 仅前端设计
      b. ⚙️ 仅后端设计
      c. 🔗 前端 + 后端（全栈）← 默认

   确认后我将按顺序逐一给出设计方案。
   ```

   等待用户确认后继续。**记住用户选择的设计范围，后续所有模块都按此范围输出。**

   > **设计范围说明：**
   >
   > - **仅前端**：只输出前端设计（组件结构、状态管理、交互流程），后端接口仅列出调用规格（方法+路径+参数），不展开设计
   > - **仅后端**：只输出后端设计（接口、数据模型、业务逻辑），前端仅说明对应页面，不展开设计
   > - **全栈**：前端和后端都完整输出

5. **数据库设计规范确认**：

   在进入模块设计之前，向用户确认数据库相关规范（仅首次需要确认，后续模块复用）：

   > **注意：如果用户选择了"仅前端设计"，跳过此步骤。**

   ```
   在开始设计之前，请确认数据库相关规范：

   1. 🗄️ 使用什么数据库？
      a. MySQL（推荐，通用性强）
      b. PostgreSQL（功能更丰富）
      c. MongoDB（文档型，适合灵活结构）
      d. 其他：___
      e. 由你推荐

   2. 📝 表名前缀？
      a. 不需要前缀（如：user, order）
      b. 项目缩写前缀（如：tm_user, tm_order）
      c. 模块前缀（如：sys_user, biz_order）
      d. 自定义前缀：___

   3. 📐 字段命名风格？
      a. 下划线命名（如：created_at, user_name）← 推荐
      b. 驼峰命名（如：createdAt, userName）

   4. 🔑 主键策略？
      a. 自增 ID（BIGINT AUTO_INCREMENT）
      b. UUID
      c. 雪花算法 ID
      d. 由你推荐

   5. 📋 通用字段？以下字段是否每张表都需要？
      - id（主键）             ✅ 默认包含
      - created_at（创建时间）  ✅ 默认包含
      - updated_at（更新时间）  ✅ 默认包含
      - created_by（创建人）    ❓ 是否需要？
      - updated_by（更新人）    ❓ 是否需要？
      - deleted（软删除标记）    ❓ 是否需要？
      - remark（备注）          ❓ 是否需要？

   6. 🔗 其他规范？
      - 是否需要数据库版本管理（如 Flyway / Liquibase）？
      - 是否有分库分表需求？
      - 字符集偏好（默认 utf8mb4）？

   可以逐一回答，也可以说"全部默认"或"由你决定"。
   ```

   **如果用户选择"由你决定"或"全部默认"，使用以下默认规范：**

   | 规范项   | 默认值                              |
   | -------- | ----------------------------------- |
   | 数据库   | MySQL 8.0                           |
   | 表名前缀 | 无前缀                              |
   | 字段命名 | 下划线命名                          |
   | 主键策略 | BIGINT AUTO_INCREMENT               |
   | 通用字段 | id, created_at, updated_at, deleted |
   | 字符集   | utf8mb4                             |

   确认后，将此规范应用于后续所有模块的数据库设计中。

### 阶段 2：逐模块设计

**对每个功能模块执行以下流程：**

#### 2.1 功能点澄清

**在设计之前，检查该功能模块是否有不明确的地方。如果有，必须先向用户提问：**

```
在设计「[模块名]」方案之前，我需要确认以下几点：

1. ❓ [不明确的问题1]
   例如：用户认证是否需要支持第三方登录（微信/钉钉）？
2. ❓ [不明确的问题2]
   例如：会话管理使用 Token 还是 Session？
3. ❓ [不明确的问题3]

请逐一回答，或者告诉我"由你决定"，我会给出推荐方案。
```

**常见需要澄清的问题类型：**

- 功能边界：这个功能具体包含哪些子功能？
- 数据规模：预计数据量级？需要考虑大数据场景吗？
- 实时性要求：是否需要实时更新？对延迟敏感吗？
- 安全要求：有特殊的安全等级要求吗？
- 集成需求：需要与哪些外部系统对接？
- 历史包袱：是否有已有系统需要兼容？

**如果所有功能点都明确，可以跳过此步骤直接进入设计。**

#### 2.2 生成设计方案

**根据用户在阶段 1 选择的设计范围，输出对应内容：**

| 用户选择  | 前端设计          | 后端设计              | 前后端交互  |
| --------- | ----------------- | --------------------- | ----------- |
| 🖥️ 仅前端 | ✅ 完整输出       | 📋 仅列出接口调用规格 | ❌ 跳过     |
| ⚙️ 仅后端 | 📋 仅说明对应页面 | ✅ 完整输出           | ❌ 跳过     |
| 🔗 全栈   | ✅ 完整输出       | ✅ 完整输出           | ✅ 完整输出 |

**你必须按照以下结构输出每个模块的设计方案（根据范围跳过不需要的部分）：**

````
## 模块 [N]：[模块名称]

### 📌 功能概述

[简要描述该模块的核心功能和业务背景]

---

### 🖥️ 前端设计

#### 页面/组件结构

```
[组件名]/
├── index.tsx                # 入口组件
├── components/
│   ├── [子组件1].tsx
│   └── [子组件2].tsx
├── hooks/
│   └── use[Hook名].ts       # 自定义 Hook
├── types/
│   └── index.ts             # 类型定义
└── services/
    └── api.ts               # 接口调用
```

#### 核心组件说明

| 组件名 | 职责 | 关键 Props/State |
|--------|------|-----------------|
| [组件1] | [职责] | [关键数据] |
| [组件2] | [职责] | [关键数据] |

#### 状态管理方案

[描述该模块的状态管理策略，如使用 Zustand/Pinia/Redux 的哪些 store]

#### 关键交互流程

```
用户操作 → 触发事件 → 调用 API → 更新状态 → 重新渲染
```

---

### ⚙️ 后端设计

#### 接口设计

| 方法 | 路径 | 描述 | 请求参数 | 响应 |
|------|------|------|---------|------|
| POST | /api/xxx | [描述] | {字段说明} | {响应说明} |
| GET | /api/xxx | [描述] | {字段说明} | {响应说明} |

#### 数据模型

```sql
CREATE TABLE [表名] (
    id          BIGINT PRIMARY KEY AUTO_INCREMENT,
    [字段名]    [类型]     [约束]    COMMENT '[说明]',
    created_at  DATETIME   NOT NULL  DEFAULT CURRENT_TIMESTAMP,
    updated_at  DATETIME   NOT NULL  DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);
```

#### 核心业务逻辑

```
1. [步骤1说明]
2. [步骤2说明]
3. [步骤3说明]
```

#### 关键技术点

- **[技术点1]**：[说明]
- **[技术点2]**：[说明]

---

### 🔗 前后端交互流程

```
┌─────────┐         ┌─────────┐         ┌─────────┐
│  前端   │ ──请求── │  后端   │ ──查询── │  数据库  │
│         │ ←─响应── │         │ ←─结果── │         │
└─────────┘         └─────────┘         └─────────┘
```

[描述关键的前后端交互时序]
````

#### 2.3 多方案推荐（如适用）

**当某个技术点存在多种可行方案时，必须提供对比和推荐：**

```
### 🔀 方案对比：[技术点名称]

针对「[具体问题]」，有以下几种方案：

#### 方案 A：[方案名称] ⭐ 推荐

**技术选型**：[具体技术]

**实现思路**：
[简要描述]

**选择理由**：
- ✅ [优点1]
- ✅ [优点2]
- ⚠️ [注意事项]

**适用场景**：[什么情况下选这个]

---

#### 方案 B：[方案名称]

**技术选型**：[具体技术]

**实现思路**：
[简要描述]

**选择理由**：
- ✅ [优点1]
- ✅ [优点2]
- ❌ [缺点]

**适用场景**：[什么情况下选这个]

---

#### 方案 C：[方案名称]（备选）

[同上格式]

---

### 📊 方案对比表

| 维度 | 方案 A | 方案 B | 方案 C |
|------|--------|--------|--------|
| 开发复杂度 | ⭐⭐ | ⭐⭐⭐ | ⭐ |
| 性能 | ⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ |
| 可维护性 | ⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐ |
| 学习成本 | ⭐⭐ | ⭐⭐⭐⭐ | ⭐ |
| 社区生态 | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐ |

**💡 我的推荐**：方案 A，理由是[简述]。

请选择你倾向的方案（A/B/C），或者告诉我你的其他想法。
```

**常见需要多方案推荐的场景：**

| 技术决策     | 典型方案                                  |
| ------------ | ----------------------------------------- |
| 前端状态管理 | Zustand / Pinia / Redux Toolkit / Jotai   |
| 后端架构     | 单体 / 微服务 / Serverless                |
| 数据库选型   | MySQL / PostgreSQL / MongoDB              |
| 缓存策略     | Redis / 本地缓存 / CDN                    |
| 认证方案     | JWT / Session / OAuth 2.0 / SSO           |
| 实时通信     | WebSocket / SSE / 轮询                    |
| 文件存储     | OSS / 本地 / MinIO                        |
| 搜索方案     | 数据库 LIKE / Elasticsearch / MeiliSearch |
| 任务队列     | RabbitMQ / Redis Queue / Kafka            |
| API 风格     | RESTful / GraphQL / gRPC                  |

#### 2.4 用户确认

每个模块设计完成后，等待用户反馈：

```
模块「[模块名]」设计方案已完成！

请查看后告诉我：
1. ✅ 方案满意，继续下一个模块
2. ✏️ 需要调整某些设计
3. ❓ 对某个技术点有疑问
4. 🔀 想换一种方案

你的选择？
```

**必须等用户确认后再进入下一个模块。**

### 阶段 3：全局架构设计

**所有模块设计完成后，输出全局视角的架构设计：**

```
## 🏗️ 系统整体架构

### 技术栈汇总

| 层次 | 技术选型 | 用途 |
|------|---------|------|
| 前端框架 | [技术] | [用途] |
| 状态管理 | [技术] | [用途] |
| UI 组件库 | [技术] | [用途] |
| 后端框架 | [技术] | [用途] |
| 数据库 | [技术] | [用途] |
| 缓存 | [技术] | [用途] |
| 其他 | [技术] | [用途] |

### 系统架构图

[使用文字或 ASCII 描述系统架构]

### 项目结构建议

[给出前端和后端的目录结构建议]

### 数据库 ER 图

[描述核心实体关系]

### 统一规范

- **API 规范**：RESTful / 请求响应格式 / 错误码定义
- **命名规范**：数据库字段 / API 路径 / 前端组件
- **错误处理**：统一异常处理策略
- **日志规范**：日志级别和格式
```

### 阶段 4：输出完整设计文档

**将所有模块的设计方案整合为一份完整的设计文档，保存为 Markdown 文件：**

文件名格式：`[项目名]_开发设计方案.md`

```markdown
# [项目名称] 前后端开发设计方案

> 文档版本：v1.0

> 创建日期：[日期]
> 技术栈：[前端] + [后端] + [数据库]

## 目录

1. [技术栈总览](#1-技术栈总览)
2. [系统架构](#2-系统架构)
3. [模块设计](#3-模块设计)
   - 3.1 [模块1名称]
   - 3.2 [模块2名称]
   - ...
4. [数据库设计](#4-数据库设计)
5. [接口设计总览](#5-接口设计总览)
6. [统一规范](#6-统一规范)
7. [部署方案](#7-部署方案)

[各章节内容]
```

### 阶段 5：文档导出询问

**设计文档生成后，询问用户后续操作：**

```
✅ 开发设计方案已生成！

📄 文件：[文件路径]

你可以：
1. 📕 导出为 PDF（调用 markdown-to-pdf-skill）
2. ✏️ 修改某个模块的设计
3. 📐 根据设计方案生成原型图（调用 html-prototype-skill）
4. 🤖 生成 AI 开发指令（打包给 AI 进行开发）
5. 📏 打包为 AI 编辑器项目规则（Cursor / Trae / Windsurf 等）
6. ✅ 确认完成

你的选择？
```

### 阶段 6：打包为 AI 编辑器规则

**当用户选择"打包为 AI 编辑器规则"时执行此阶段。**

#### 6.1 询问目标编辑器和规则类型

```
请确认打包信息：

1. 目标 AI 编辑器？（可多选）
   a. Cursor
   b. Trae
   c. Windsurf
   d. GitHub Copilot
   e. 通用 Markdown 格式（适用于所有编辑器）

2. 规则类型？
   a. 📁 项目规则 — 仅作用于当前项目（放在项目根目录）
   b. 🌍 全局规则 — 作用于所有项目（放在用户配置目录）
   c. 📁 + 🌍 两者都要

你的选择？
```

#### 6.2 生成规则文件

**根据用户选择的编辑器和规则类型，生成对应的规则文件。**

##### 编辑器规则文件对照表

| 编辑器             | 项目规则文件                      | 全局规则文件                                   |
| ------------------ | --------------------------------- | ---------------------------------------------- |
| **Cursor**         | `.cursor/rules/[规则名].mdc`      | `~/.cursor/rules/[规则名].mdc`                 |
| **Trae**           | `.trae/rules/[规则名].md`         | `~/.trae/rules/[规则名].md`                    |
| **Windsurf**       | `.windsurfrules`                  | `~/.codeium/windsurf/memories/global_rules.md` |
| **GitHub Copilot** | `.github/copilot-instructions.md` | 不支持全局规则                                 |
| **通用格式**       | `.ai-rules/[规则名].md`           | `~/.ai-rules/[规则名].md`                      |

##### Cursor 规则文件格式 (.mdc)

**Cursor 的 `.mdc` 文件有特殊的 frontmatter 格式：**

```markdown
---
description: [规则描述，Cursor 用此判断何时应用此规则]
globs: [文件匹配模式，如 "src/**/*.ts" 或留空表示全局]
alwaysApply: [true/false，是否始终应用]
---

[规则内容]
```

##### 规则内容结构

**不管哪种编辑器，规则内容都应包含以下核心信息：**

```markdown
# [项目名称] 开发规范

## 项目概述

- **项目名称**：[名称]
- **项目描述**：[描述]
- **技术栈**：[前端框架] + [后端框架] + [数据库]
- **UI 框架**：[UI 组件库]

## 技术栈规范

### 前端技术栈

- 框架：[如 React 18 + TypeScript]
- 状态管理：[如 Zustand]
- UI 组件库：[如 Ant Design 5.x]
- 路由：[如 React Router v6]
- HTTP 请求：[如 Axios]
- 构建工具：[如 Vite]

### 后端技术栈

- 框架：[如 Spring Boot 3.x + Java 17]
- ORM：[如 MyBatis Plus]
- 数据库：[如 MySQL 8.0]
- 缓存：[如 Redis]
- 认证：[如 JWT]

## 编码规范

### 前端编码规范

- 组件命名使用 PascalCase：`UserProfile.tsx`
- Hook 命名以 `use` 开头：`useUserList.ts`
- 接口定义文件统一放在 `types/` 目录
- API 调用统一封装在 `services/` 目录
- [从设计方案中提取的其他规范]

### 后端编码规范

- 遵循分层架构：Controller → Service → Mapper
- 统一响应格式：`{ code: number, message: string, data: T }`
- 异常统一通过全局异常处理器捕获
- 数据库字段使用下划线命名：`created_at`
- [从设计方案中提取的其他规范]

## 项目结构

### 前端项目结构
```

src/
├── components/ # 公共组件
├── pages/ # 页面组件
├── hooks/ # 自定义 Hook
├── services/ # API 接口
├── stores/ # 状态管理
├── types/ # 类型定义
├── utils/ # 工具函数
└── styles/ # 全局样式

```

### 后端项目结构
```

src/main/java/com/xxx/
├── controller/ # 控制器层
├── service/ # 业务逻辑层
│ └── impl/
├── mapper/ # 数据访问层
├── entity/ # 实体类
├── dto/ # 数据传输对象
├── vo/ # 视图对象
├── config/ # 配置类
├── common/ # 公共模块
│ ├── exception/ # 异常处理
│ └── result/ # 统一响应
└── utils/ # 工具类

```

## API 设计规范

- 使用 RESTful 风格
- 路径使用小写 + 连字符：`/api/user-profiles`
- 分页参数：`page`（从1开始）、`size`（每页条数）
- 统一错误码定义：[列出核心错误码]

## 数据库规范

- 表名使用小写 + 下划线：`user_profile`
- 每张表必须包含：`id`, `created_at`, `updated_at`
- 软删除字段：`deleted`（0=未删除，1=已删除）
- 索引命名：`idx_[表名]_[字段名]`

## 安全规范

- [认证方案说明]
- [权限控制策略]
- [数据安全要求]
```

##### 根据规则类型拆分内容

**项目规则（侧重具体实现细节）：**

- 项目结构和文件组织
- 编码规范和命名约定
- 接口设计和数据模型
- 模块间的依赖关系

**全局规则（侧重通用开发习惯）：**

- 编程语言通用规范
- 代码风格偏好
- 注释和文档要求
- Git 提交规范
- 错误处理策略

##### Cursor 多文件规则拆分（推荐）

**对于 Cursor，推荐按职责拆分为多个 `.mdc` 文件：**

```
.cursor/rules/
├── project-overview.mdc       # 项目概述和技术栈（alwaysApply: true）
├── frontend-rules.mdc         # 前端编码规范（globs: "src/**/*.{ts,tsx}"）
├── backend-rules.mdc          # 后端编码规范（globs: "**/*.java"）
├── database-rules.mdc         # 数据库规范（globs: "**/*.sql"）
└── api-design-rules.mdc       # API 设计规范（globs: "**/controller/**"）
```

每个文件的 `globs` 字段确保规则只在编辑相关文件时生效。

#### 6.3 生成完成提示

```
✅ AI 编辑器规则已生成！

📁 已生成的规则文件：

[Cursor 项目规则]
├── .cursor/rules/project-overview.mdc
├── .cursor/rules/frontend-rules.mdc
├── .cursor/rules/backend-rules.mdc
├── .cursor/rules/database-rules.mdc
└── .cursor/rules/api-design-rules.mdc

[Trae 项目规则]
└── .trae/rules/dev-design-rules.md

🚀 使用方式：
- Cursor：规则会自动生效，编辑代码时 AI 会自动遵循
- Trae：规则会自动生效

需要调整规则内容吗？
```

#### 6.4 用户确认

```
请查看生成的规则文件，确认内容是否准确：
1. ✅ 满意，规则生成完成
2. ✏️ 需要修改某条规则
3. ➕ 需要追加自定义规则
4. 🔄 重新生成

你的选择？
```

## ⚠️ 重要规则

1. **逐模块设计**：必须一个模块一个模块输出，等用户确认后再继续
2. **主动澄清**：遇到模糊功能点必须先提问，不要自行假设
3. **技术选型有理由**：每个技术选择都必须说明"为什么选它"
4. **多方案推荐**：关键决策点必须给出至少 2 种方案供选择
5. **前后端兼顾**：每个模块同时设计前端和后端，不能遗漏
6. **实用导向**：设计方案必须可落地，不要空洞的架构描述
7. **标注复杂度**：让用户清楚每个模块的开发难度
8. **关联 Skill**：在合适时机推荐配套 Skill（PDF 导出、原型图等）
9. **规则文件格式正确**：生成的规则文件必须严格遵循目标编辑器的格式要求
10. **规则内容来源于设计方案**：规则内容必须从设计方案中提取，不是凭空编造

## 📝 技术选型理由模板

推荐技术时，必须按照以下维度说明理由：

```
**为什么选择 [技术名]？**

1. **功能匹配**：[这个技术如何满足当前需求]
2. **团队适配**：[团队是否熟悉/学习成本如何]
3. **生态成熟度**：[社区规模/文档质量/更新频率]
4. **性能表现**：[在当前场景下的性能预期]
5. **长期维护**：[可维护性/可扩展性/升级路径]
```

## 📚 相关 Skill

- **requirement-design-skill** — 需求文档生成器（上游输入）
- **html-prototype-skill** — HTML 原型图生成器（可视化验证）
- **markdown-to-pdf-skill** — 导出 PDF（文档交付）
